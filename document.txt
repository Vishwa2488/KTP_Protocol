╔════════════════════════════════════════════════════════════════╗
║                       IMPLEMENTATION REPORT                    ║
║                   KGP TRANSPORT PROTOCOL (KTP) SOCKET          ║
╚════════════════════════════════════════════════════════════════╝

═════════════════════════ DATA PACKET STRUCTURE ═════════════════════════
Each KTP data packet consists of:

msg_type: Identifies the type of message (1 = DATA, 2 = ACK).

seq_num: Sequence number of the packet (used for in-order delivery).

Union of:

data[MSG_SIZE]: The actual message payload.

rwnd: The receiver's window size (sent in ACKs for flow control).

This structure forms the fundamental unit of communication between sender and receiver.

════════════════════════ SENDER WINDOW (SWND) ════════════════════════
Manages the sender's sliding window protocol. Key fields:

swnd: The number of unacknowledged messages currently in transit.

next_seq_num: The next sequence number to be assigned to a message.

last_ack: The highest sequence number that has been acknowledged.

send_buffer[MAX_SEQNUM][MSG_SIZE]: Circular buffer storing unacknowledged messages.

send_timestamps[MAX_SEQNUM]: Timestamps of when each message was last sent.

udp_sock: UDP socket used for sending data.

retransmit_nospace: Flag to indicate retransmission due to lack of space in the receiver.

SLIDING WINDOW LOGIC (THREAD S - SENDER THREAD)

Immediate Send Strategy: When k_sendto() enqueues a message, it is immediately sent instead of waiting for thread_S to do it.

Timeout-Based Retransmissions:

Thread S checks for timeouts using timestamps stored in send_timestamps.

If a message times out (elapsed_time >= T), it is retransmitted.

No Unnecessary Packet Injection: Thread S does NOT send new packets unless explicitly enqueued by k_sendto().

════════════════════════ RECEIVER WINDOW (RWND) ════════════════════════
Manages the receiver’s sliding window protocol. Key fields:

rwnd: Number of free slots in the receiver’s buffer.

expected_seq: The next expected sequence number for in-order delivery.

rcv_buf[MAX_SEQNUM][MSG_SIZE]: Circular buffer to store received messages.

RECEIVING LOGIC (THREAD R - RECEIVER THREAD)

Message Ordering:

If the received sequence number matches expected_seq, the message is stored in rcv_buf at the appropriate index (MAX_SEQNUM - rwnd).

expected_seq is incremented, and rwnd is decremented to reflect used space.

ACK Handling:

ACKs are sent back to the sender after each successful reception.

If an ACK acknowledges new data (seq_num > last_ack), last_ack is updated, and the sender window (swnd) is slid forward.

Thread R signals pthread_cond_signal(&ack_cv) to wake waiting sender processes.

════════════════════════ KTP SOCKET MANAGEMENT ════════════════════════
Each KTP socket is managed as an entry in shared memory. Fields include:

is_use: Status of the socket (allocated, bound, closing, etc.).

pid: Process ID of the process that allocated the socket.

udp_sock: Underlying UDP socket descriptor.

src_addr: Source address (struct sockaddr_in).

dest_addr: Destination address (struct sockaddr_in).

send_buffer: Storage for unacknowledged outgoing messages.

rcv_buf: Storage for received messages awaiting application retrieval.

swnd: Sender window structure (tracks unacknowledged messages).

rwnd: Receiver window structure (tracks available buffer space).

send_timestamps: Stores send times for timeout-based retransmissions.

timeout_tries: Counts retransmission attempts for each packet.

pthread_cond_t ack_cv: Condition variable used to block/unblock waiting processes.

════════════════════════ BLOCKING MECHANISM IN K_SENDTO() AND K_RECVFROM() ════════════════════════

k_sendto() now blocks when the send window is full:

It waits (pthread_cond_wait()) until an ACK arrives and makes space.

After sending a message, it immediately records the send timestamp.

k_recvfrom() now blocks when no data is available:

Instead of returning -1, it waits on pthread_cond_wait() until a new message is received.

Once woken, it retrieves the oldest message in the buffer, shifts remaining messages left, and increases rwnd.

════════════════════════ TIME MANAGEMENT USING NANOSLEEP() ════════════════════════
Instead of sleep(), we use usleep() to allow for precise, sub-second sleep intervals.
This enables efficient scheduling of sender/receiver operations without unnecessary delays.

════════════════════════ PERFORMANCE TABLE ═════════════════════════

┌──────────────┬─────────────────┬────────────────┬───────────┐
│   P Value    │ Total Messages  │ Transmissions  │   Ratio   │
├──────────────┼─────────────────┼────────────────┼───────────┤
│    0.05      │       31        │        42      │    1.3    │
├──────────────┼─────────────────┼────────────────┼───────────┤
│    0.10      │       31        │        42      │    1.3    │
├──────────────┼─────────────────┼────────────────┼───────────┤
│    0.15      │       31        │        42      │    1.3    │
├──────────────┼─────────────────┼────────────────┼───────────┤
│    0.20      │       31        │        51      │    1.6    │
├──────────────┼─────────────────┼────────────────┼───────────┤
│    0.30      │       31        │        54      │    1.7    │
├──────────────┼─────────────────┼────────────────┼───────────┤
│    0.50      │       31        │        67      │    2.2    │
└──────────────┴─────────────────┴────────────────┴───────────┘